//
// File to declare which enum values have to be available even in dynamic DLLs
//
// The problem solved here is that the enum values are freely available in hardcoded DLLs, but using them will make the dynamic DLL fail to compile.
// At compile time, any enum value mentioned here will be autogenerated as a global read only variable and set automatically while reading xml.
// This allows the enum variables to be used anywhere in the code just like it's hardcoded enums.
// Adding an enum here, which isn't in xml will cause an error message at startup. This will catch the case when the xml files are changed.
//
// This will not affect hardcoded DLL files as they still rely on the hardcoded enums, hence knowing the values at compile time.
//
// Note: since the compiler itself will not see this file, order doesn't matter and partial enums are allowed.
//       in fact it would be best to only include the enums, which are actually used in the code.
//
// Design consideration: in many cases it's bad design to mention explicit enum types as it can restrict what can be done in xml later.
//                       please consider if reading data from xml info classes could be a better solution as it grants more xml freedom.
//
//  Nightinggale
//

//
// WARNING: only lines ending with a comma (,) will be used meaning even the last entry in an enum needs to end with a comma
//

enum BonusTypes
{
	BONUS_HIGH_SEA_FISH,
	BONUS_HIGH_SEA_FISH2,
	BONUS_HIGH_SEA_FISH3,
	BONUS_HIGH_SEA_FISH4,
	BONUS_HUMPBACK_WHALE,
	BONUS_WHALE,
};

enum BuildingTypes
{
	BUILDING_CHICKEE,
	BUILDING_PLACEHOLDER,
};

enum CivEffectTypes
{
	CIV_EFFECT_DEFAULT_ALL,
	CIV_EFFECT_DEFAULT_EUROPEAN,
	CIV_EFFECT_DEFAULT_NATIVE,
	CIV_EFFECT_DEFAULT_KING,
	CIV_EFFECT_DEFAULT_BARBARIAN,
	CIV_EFFECT_DEFAULT_CHURCH,
	CIV_EFFECT_DEFAULT_HUMAN,
	CIV_EFFECT_DEFAULT_AI,
};

enum CivilizationTypes
{
	CIVILIZATION_BARBARIAN,
	CIVILIZATION_CHURCH,
};

enum EffectTypes
{
	EFFECT_SETTLERSMOKE,
};

enum LeaderHeadTypes
{
	LEADER_BARBARIAN,
	LEADER_CHURCH,
};

enum ProfessionTypes
{
	PROFESSION_MISSIONARY,
	PROFESSION_NATIVE_TRADER,

	PROFESSION_FISHING_BOAT_WORKING,
	PROFESSION_WHALING_BOAT_WORKING,
};

enum SpecialUnitTypes
{
	SPECIALUNIT_COLONIST_UNIT,
	SPECIALUNIT_YIELD_CARGO,
};

enum UnitClassTypes
{
	UNITCLASS_AFRICAN_SLAVE,
	UNITCLASS_BISHOP,
	UNITCLASS_BRAVE_LIEUTENANT,
	UNITCLASS_CAPABLE_CAPTAIN,
	UNITCLASS_COLONIST,
	UNITCLASS_CONQUISTADOR,
	UNITCLASS_CONTINENTAL_GUARD,
	UNITCLASS_FAILED_MISSIONARY,
	UNITCLASS_FAILED_TRADER,
	UNITCLASS_FISHING_BOAT,
	UNITCLASS_GREAT_ADMIRAL,
	UNITCLASS_GREAT_GENERAL,
	UNITCLASS_MILITIA,
	UNITCLASS_MORTAR,
	UNITCLASS_MOUNTED_CONQUISTADOR,
	UNITCLASS_NATIVE_MERC,
	UNITCLASS_NATIVE_SLAVE,
	UNITCLASS_NOBLE,
	UNITCLASS_PIRATE_FRIGATE,
	UNITCLASS_PRISONER_OF_WAR,
	UNITCLASS_RANGER,
	UNITCLASS_SMUGGLING_SHIP,
	UNITCLASS_TREASURE,
	UNITCLASS_VETERAN,
	UNITCLASS_WHALING_BOAT,
};

enum UnitCombatTypes
{
	UNITCOMBAT_GUN,
	UNITCOMBAT_SIEGE,
};

enum UnitTypes
{
	UNIT_PLACEHOLDER,
};

#include "CvEnums.h"


// declare InfoArrays here if the autogenerated InfoArrays fails to detect this
// this happens if an InfoArray is declared using a template argument as the scripted specialization can't detect this

InfoArray<SpecialBuildingTypes>;
InfoArray<UnitTypes>;


