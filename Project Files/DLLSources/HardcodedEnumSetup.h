//
// File to declare which enum values have to be available even in dynamic DLLs
//
// The problem solved here is that the enum values are freely available in hardcoded DLLs, but using them will make the dynamic DLL fail to compile.
// At compile time, any enum value mentioned here will be autogenerated as a global read only variable and set automatically while reading xml.
// This allows the enum variables to be used anywhere in the code just like it's hardcoded enums.
// Adding an enum here, which isn't in xml will cause an error message at startup. This will catch the case when the xml files are changed.
//
// This will not affect hardcoded DLL files as they still rely on the hardcoded enums, hence knowing the values at compile time.
//
// Note: since the compiler itself will not see this file, order doesn't matter and partial enums are allowed.
//       in fact it would be best to only include the enums, which are actually used in the code.
//
// Design consideration: in many cases it's bad design to mention explicit enum types as it can restrict what can be done in xml later.
//                       please consider if reading data from xml info classes could be a better solution as it grants more xml freedom.
//
//  Nightinggale
//

//
// WARNING: only lines ending with a comma (,) will be used meaning even the last entry in an enum needs to end with a comma
//

enum BuildingTypes
{
	BUILDING_PLACEHOLDER,
};

enum CivEffectTypes
{
	CIV_EFFECT_DEFAULT_ALL,
	CIV_EFFECT_DEFAULT_EUROPEAN,
	CIV_EFFECT_DEFAULT_NATIVE,
	CIV_EFFECT_DEFAULT_KING,
	CIV_EFFECT_DEFAULT_BARBARIAN,
	CIV_EFFECT_DEFAULT_CHURCH,
	CIV_EFFECT_DEFAULT_HUMAN,
	CIV_EFFECT_DEFAULT_AI,
};

enum CivilizationTypes
{
	BARBARIAN_CIVILIZATION,
	CHURCH_CIVILIZATION,
};

enum EffectTypes
{
	EFFECT_SETTLERSMOKE,
};

enum LeaderHeadTypes
{
	BARBARIAN_LEADER,
	CHURCH_LEADER,
};

enum ProfessionTypes
{
	PROFESSION_MISSIONARY,
	PROFESSION_NATIVE_TRADER,

	PROFESSION_FISHING_BOAT_WORKING,
	PROFESSION_WHALING_BOAT_WORKING,
};

enum SpecialUnitTypes
{
	SPECIALUNIT_COLONIST_UNIT,
	SPECIALUNIT_YIELD_CARGO,
};

enum UnitClassTypes
{
	UNITCLASS_COLONIST,
	UNITCLASS_NATIVE_MERC,
	UNITCLASS_NATIVE_SLAVE,
	UNITCLASS_NOBLE,
	UNITCLASS_BISHOP,
	UNITCLASS_SMUGGLING_SHIP,
	UNITCLASS_RANGER,
	UNITCLASS_MOUNTED_CONQUISTADOR,
	UNITCLASS_CONQUISTADOR,
	UNITCLASS_PIRATE_FRIGATE,
	UNITCLASS_CONTINENTAL_GUARD,
	UNITCLASS_MORTAR,

	UNITCLASS_FISHING_BOAT,
	UNITCLASS_WHALING_BOAT,

	UNITCLASS_CAPABLE_CAPTAIN,
	UNITCLASS_GREAT_ADMIRAL,
	UNITCLASS_GREAT_GENERAL,
	UNITCLASS_BRAVE_LIEUTENANT,
};

enum UnitCombatTypes
{
	UNITCOMBAT_GUN,
	UNITCOMBAT_SIEGE,
};

enum UnitTypes
{
	UNIT_PLACEHOLDER,
};

#include "CvEnums.h"

// declare which setups of InfoArray, which needs to be generated
// 1 indexed variable location (1, 2, 3, 4)

// a few template declarations to let the IDE highlight keywords correctly (otherwise ignored)
template <typename T> class InfoArray1;
template <typename T> class InfoArray2;
template <typename T> class InfoArray3;
template <typename T> class InfoArray4;

InfoArray2<int>;
InfoArray3<int>;

InfoArray1<BonusTypes>;
InfoArray1<BuildTypes>;
InfoArray1<BuildingTypes>;
InfoArray1<BuildingClassTypes>;
InfoArray1<CivCategoryTypes>;
InfoArray1<CivicTypes>;
InfoArray1<EventTypes>;
InfoArray1<FeatureTypes>;
InfoArray1<ImprovementTypes>;
InfoArray1<PlotTypes>;
InfoArray1<ProfessionTypes>;
InfoArray1<PromotionTypes>;
InfoArray2<PromotionTypes>;
InfoArray1<RouteTypes>;
InfoArray1<SpecialBuildingTypes>;
InfoArray1<TerrainTypes>;
InfoArray1<UnitTypes>;
InfoArray1<UnitClassTypes>;
InfoArray1<UnitCombatTypes>;
InfoArray1<YieldTypes>;


