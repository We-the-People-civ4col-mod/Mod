#!/usr/bin/perl -w

#
# Attempts to self configure paths for the makefile
# Using this file rather than the makefile itself allows much cleaner code for checking multiple locations.
# If all the right locations are checked, the compiler becomes more self configuring and less setup is needed.
#

use strict;
use warnings;


my $file = "Makefile.auto";


my $ProgramFiles   = "12345678";

if (scalar @ARGV == 1)
{
	$ProgramFiles = $ARGV[0];
}


my @paths = ();
my @flags = ();
my %flag_values = ();

my $updated = 0;

readOldFile();

# directories to search
push(@paths, "..\\..\\Compiler");
push(@paths, $ProgramFiles) unless $ProgramFiles eq "12345678";
push(@paths, substr($ProgramFiles, 0, -6)) if substr($ProgramFiles, -5) eq "(x86)";


# files to look for in each searched directory
# Note that if the same flag (first argument) is used more than once, it will use the first, which finds the file
# This allows searching multiple different locations for the same file
process("TOOLKIT", "\\Microsoft Visual C++ Toolkit 2003");
process("PSDK", "\\Microsoft SDKs\\Windows\\v6.0");
process("GIT", "\\SmartGit\\git\\bin\\git.exe");
process("GIT", "\\Git\\cmd\\git.exe");

exit if $updated == 0;

open (my $output, "> " . $file) or die "Can't open file " . $file . "\n" . $!;

print $output "# Autogenerated file.\n";
print $output "# Changing a path is ok and should be remembered.\n";
print $output "# Adding flags is not and they risk vanishing.\n";
print $output "# Use Makefile.settings for your custom flags.\n";
print $output "\n";

foreach my $flag (@flags)
{
	my $dir = 0;
	$dir = 1 if exists $flag_values{$flag} and -d $flag_values{$flag};
	print $output $flag;
	print $output "=";
	print $output "\"" unless $dir;
	print $output $flag_values{$flag} if exists $flag_values{$flag};
	print $output "\"" unless $dir;
	print $output "\n";
}

close $output;

exit;

sub process
{
	my $flag = shift;
	my $file = shift;
	
	push(@flags, $flag) unless containsFlag($flag);
	
	return if exists $flag_values{$flag} and length($flag_values{$flag}) > 3 and -e $flag_values{$flag};
	
	foreach my $path (@paths)
	{
		my $full_path = $path . $file;
		if (-e $full_path)
		{
			$updated = 1;
			$flag_values{$flag} = $full_path;
		}
	}
}

sub containsFlag
{
	my $new_flag = shift;
	
	foreach my $flag (@flags)
	{
		return 1 if $flag eq $new_flag;
	}
	
	return 0;
}

sub readOldFile
{
	return unless -e $file;
	
	open my $handle, '<', $file;
	chomp(my @lines = <$handle>);
	close $handle;
	
	for my $line (@lines)
	{
		next if index($line, "=") eq -1;
		my @tokens = split "=", $line;
		my $flag = $tokens[0];
		my $path = $tokens[1];
		if (substr($path, 0, 1) eq "\"")
		{
			$path = substr($path, 1);
			$path = substr($path, 0, -1);
		}
		$flag_values{$flag} = $path;
	}
}